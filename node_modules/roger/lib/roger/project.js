/* jshint globalstrict: true, strict: false, undef: true, unused: true,
          trailing: true, browser: true, smarttabs:true */
/* global require, module */

var extend = require('util')._extend,
    fs = require('fs'),
    q = require('q'),
    rmdir = require('rimraf'),
    util = require('./util'),
    Repo = require('./repo'),
    Dependencies = require('./dependencies');

require('colors');

function loadProjectConfig(path, repo, cache) {
  var remote = repo.toString(),
      deferred = q.defer(),
      config;

  if (cache.configs.hasOwnProperty(remote)) {
    config = cache.configs[remote];
    deferred.resolve(config);
  }
  else {
    fs.readFile(path + 'package.json', function (err, data) {
      if (err) {
        deferred.reject(err);
        return;
      }

      config = JSON.parse(data);
      cache.configs[remote] = config;
      deferred.resolve(config);
    });
  }

  return deferred.promise;
}

function getTopLevelCachePath(parent, defaultPath) {
  var p = parent;
  while (p && p.parent) {
    p = p.parent;
  }

  return (p ? p.path : defaultPath) + 'tmp/dependency_cache/';
}

function loadSubProjects(path, parent, cache, depth) {
  var dependenciesPath = Dependencies.dependencyPathFor(parent.path),
      childOptions = { parent: parent },
      loadTasks = q();

  var getProject = function(artifactName) {
    var repoDetails = parent.dependenciesDict[artifactName].split('#'),
        repoOptions = { url: repoDetails[0], branch: repoDetails[1] },
        childPath = dependenciesPath + artifactName + '/';

    childOptions.name = artifactName;
    childOptions.repo = new Repo(childPath, repoOptions, cache.path);

    return _get(childPath, cache, depth, childOptions)
                  .then(function(project) {
                    parent.dependenciesList.push(project);
                  });
  };

  util.log('Getting dependencies for ' + parent.fullName.bold);

  // Get dependencies sequentially
  Object.keys(parent.dependenciesDict).forEach(function(artifactName) {
    loadTasks = loadTasks.then(function() {
      return getProject(artifactName);
    });
  });

  return loadTasks;
}

var Project = function (path, repo, parent, cacheDir) {
  this.name = '';
  this.path = path;
  this.parent = parent;
  this.cacheDir = cacheDir;
  this.repo = repo;
  this.dependenciesPath = Dependencies.dependencyPathFor(path);
  this.dependenciesList = [];

  if (this.path[this.path.length-1] !== '/') this.path += '/';

  Object.defineProperties(this, {
    fullName: {
      get: function() {
        return this.name + '#' + this.repo.location;
      }
    },

    isTopLevel: {
      get: function() {
        return !parent;
      }
    },

    topLevelProject: {
      get: function() {
        var p = parent;

        while (p && p.parent) {
          p = p.parent;
        }

        return p || this;
      }
    },

    remote: {
      get: function() {
        return this.repo.toString();
      }
    }
  });
};

Project.prototype.targetForDependency = function(name) {
  return this.dependenciesDict[name];
};

Project.prototype.toString = Project.prototype.valueOf = function() {
  return this.name;
};


Project.prototype.loadRepo = function() {
  var asyncLoadTasks = [],
      missingRemoteUrl = !(this.repo && this.repo.url),
      missingInfo = !(this.repo &&
                        ((this.repo.branch && this.repo.remote) || this.repo.detached === true) );

  if (!missingRemoteUrl && !missingInfo) {
    return q(this);
  }

  if (missingRemoteUrl) {
    asyncLoadTasks.push(Repo.getRemoteUrlFor(this.path));
  }

  if (missingInfo) {
    asyncLoadTasks.push(Repo.getBranchInfo(this.path));
  }

  // Figure out the branch and repo then load the project
  return q.allSettled(asyncLoadTasks)
          .spread(function(repoUrl, repoInfo) {
            repoInfo = repoInfo ? repoInfo.value : (missingInfo ? repoUrl.value : {});
            if (missingRemoteUrl) repoInfo.url = repoUrl.value;

            if (!this.repo){
              this.repo = new Repo(this.path, repoInfo, this.cacheDir);
            }
            else {
              this.repo.set(repoInfo);
            }

            return this;
          }.bind(this));
};

Project.prototype.loadConfig = function(cache) {
  return loadProjectConfig(this.path, this.repo, cache)
            .then(function(config) {
              var rogerConfig = config.roger;
              this.name = rogerConfig.artifactName;
              this.buildCommand = rogerConfig.buildCommand || 'npm install';
              this.artifactFilename = rogerConfig.artifactFilename;
              this.dependenciesDict = rogerConfig.dependencies || {};

              if (rogerConfig.buildPath) {
                if (rogerConfig.buildPath.substr(-1, 1) !== '/') rogerConfig.buildPath += '/';
                this.buildPath = rogerConfig.buildPath;
              }
              else {
                this.buildPath = this.path + 'build/';
              }

              this.artifactPath = this.buildPath + 'js/' + rogerConfig.artifactFilename;

              return this;
            }.bind(this));
};

Project.prototype.getArtifact = function() {
  return q.nfcall(fs.readFile, this.artifactPath);
};

Project.load = function(path, repo, parent, cache) {
  return (new Project(path, repo, parent, cache.path))
            .loadRepo()
            .then(function(project) {
              return project.loadConfig(cache);
            });
};


//
// *Note:* Dependencies must be built sequentially for now.
Project.prototype._build = function(cache) {
  var buildTasks = q(),
      _this = this;

  if (cache.hasOwnProperty(this.remote) && cache[this.remote]) {
    util.log(this.fullName + ' is already built, skipping it.');
    return buildTasks;
  }

  // Build dependencies sequentially
  this.dependenciesList.forEach(function(dep) {
    buildTasks = buildTasks.then(dep._build.bind(dep, cache));
  });


  // ...then build ourselves, unless it's already happened or we are the top level
  // project
  if (!this.isTopLevel) {
    buildTasks = buildTasks.then(function() {
      util.log('Building ' + _this.fullName + ' with ' + _this.buildCommand +
                          ' in ' + _this.path.underline);

      return util.executeCommand(_this.buildCommand, [], _this.path).then(function() {
              console.log('BUILT', _this.fullName);
              cache[_this.remote] = true;
              return _this.dependencies;
            });
    });
  }
  else {
    buildTasks = buildTasks.then(function() {
      cache[_this.remote] = true;
      return _this.dependencies;
    });
  }

  return buildTasks;
};

Project.prototype.build = function() {
  return this._build({});
};


Project.install = function(path, repo, cache) {
  return repo.setup()
              .then(function() {
                cache.fresh.push(repo.toString());
              });
};

Project.update = function(path, repo, cache) {
  // We've already updated the repo on this run
  // assume freshness
  if (cache.fresh.indexOf(repo.toString()) > -1) {
    // @fixme This probably isn't the right way of doing this
    var deferred = q.defer();
    deferred.resolve();
    return deferred.promise;
  }

  cache.fresh.push(repo.toString());
  return repo.update();
};


Project.clean = function(path) {
  if (path[path.length-1] !== '/') path += '/';
  return q.nfcall(rmdir, path + 'tmp/dependency_cache/')
          .then(function() {
            return q.nfcall(rmdir, Dependencies.dependencyPathFor(path));
          });
};

Project.exists = function(path) {
  return util.exists(path + 'package.json');
};


Project.get = function(path, _options) {
  if (path[path.length-1] !== '/') path += '/';

  var options = extend({}, _options || {}),
      project,
      cache = {
        path: getTopLevelCachePath(options.parent, path),
        configs: {},
        fresh: [],
        known: []
      };

  return _get(path, cache, 0, options)
          .then(function(p) {
            project = p;
            return Dependencies.from(project, Project);
          })
          .then(function(dependencies) {
            // Now the dependencies should have been loaded
            project.dependencies = dependencies;
            return project;
          });
};


var _get = function _get (path, cache, depth, options) {
  var parent = options.parent,
      project,
      tasks;

  if (parent) {
    tasks = Project.exists(path)
      .then(function(exists) {
        if (exists) {
          return Project.update(path, options.repo, cache);
        }
        else {
          return Project.install(path, options.repo, cache);
        }
      })
      .then(function() {
        return Project.load(path, options.repo, parent, cache);
      });
  }
  else {
    tasks = Project.load(path, options.repo, parent, cache);
  }

  return tasks
            .then(function(p) {
              project = p;
              return loadSubProjects(path, project, cache, depth+1);
            })
            .then(function() {
              return project;
            });
};


module.exports = Project;
