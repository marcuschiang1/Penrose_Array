/* jshint globalstrict: true, strict: false, undef: true, unused: true,
          trailing: true, browser: true, smarttabs:true */
/* global require, console, exports, process */

var crossSpawn = require('cross-spawn'),
    childProcessExec = require('child_process').exec,
    fs = require('fs'),
    q = require('q');

require('colors');

exports.log = function (message, depth) {
  var i = depth || 0,
      indent = '';
  while (i-- > 0) indent += '\t';

  console.log( indent + message.valueOf().green );
};

exports.isFunction = function (fn) {
  return typeof(fn) === 'function';
};

exports.triggerAsync = function (/* callback, arg1, arg2, ..., argN */) {
  var args = Array.prototype.slice.call(arguments),
      callback = args.shift();

  return process.nextTick(function() {
    return callback.apply(null, args);
  });
};

// proxy fs.exists to return a promise. Example of q.defer
exports.exists = function (path) {
  var deferred = q.defer();

  fs.exists(path, function(result){
    return deferred.resolve(result);
  });

  return deferred.promise;
};

exports.executeCommand = function(cmd, args, cwd) {
  var deferred = q.defer();
  var fullCmd = [cmd].concat(args).join(' ');

  childProcessExec(fullCmd, {cwd: cwd}, function(error, stdout, stderr) {
    if (error) {
      error.details = stdout + '\n\n' + stderr;
      deferred.reject(error);
      return;
    }

    deferred.resolve(stdout);
  });

  return deferred.promise;
};

// @todo fix this for Windows
exports.spawnCommand = function (cmd, args, cwd) {
  var deferred = q.defer(),
      stdout = '',
      stderr = '';

  var process = crossSpawn(cmd, args, {cwd: cwd});
  process.stdout.on('data', function (data) {
    stdout += data;
  });

  process.stderr.on('data', function (data) {
    stderr += data;
  });

  var reject = function(fullCmd, errorMessage) {
    var error = new Error('Failed to execute command "' + fullCmd +
                              '" in "' + cwd +
                              '", failed with error ' + errorMessage);
    error.code = errorMessage;
    error.details = stdout + '\n\n' + stderr;
    return deferred.reject(error);
  };

  // If there is an error spawning the command, reject the promise
  process.on('error', function (errorMessage) {
    var fullCmd = [cmd];
    if (args) fullCmd.push.apply(fullCmd, args.slice());
    fullCmd = fullCmd.join(' ');

    return reject(fullCmd, errorMessage);
  });

  process.on('close', function (code) {
    if (code) {
      var fullCmd = [cmd];
      if (args) fullCmd.push.apply(fullCmd, args.slice());
      fullCmd = fullCmd.join(' ');

      return reject(fullCmd, code);
    }

    deferred.resolve(stdout);
  });

  return deferred.promise;
};
