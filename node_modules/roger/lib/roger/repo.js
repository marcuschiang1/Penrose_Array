/* jshint globalstrict: true, strict: false, undef: true, unused: true,
          trailing: true, browser: true, smarttabs:true */
/* global require, module */

var mkdirp = require('mkdirp'),
    rmdir = require('rimraf'),
    q = require('q'),
    fs = require('fs'),
    util = require('./util');

require('colors');

// A regex to match against git branch --vv output
//
// Something like:
// * dependability           a601724 [origin/dependability] remove bower references
// Or
// * dependability   e0eb13d [origin/dependability: ahead 1] add a task to clean
//
//     /^\*\s*([0-9a-zA-Z\-\_\.]+)\s+        // Current branch name
//       [a-z0-9]+\s+                        // last commit SHA
//       \[                                  // begining of remote info
//         ([0-9a-zA-Z\-\_\.\/]+)            // remote branch
//         (\:[\sa-zA-Z0-9]+)?               // remote message?
//       \]                                  // end of remote info
//       .*$                                 // ignore crap that we don't care about
//     /m                                    // multiline match
//
var branchRegEx =
/^\*\s*([0-9a-zA-Z\-\_\.\/]+)\s+([a-z0-9]+)\s+(\[([0-9a-z\-\_\.\/]+)(\:[\sa-z0-9]+)*\])?.*$/mi;

var detachedModeRegEx = /^\*\s*\(detached from ([0-9a-z\-\_\.]+)\)\s+([a-f0-9]+)/im;
var detachedMode2RegEx = /^\*\s*\([a-zA-Z0-9\_\-\.\/]+ detached at ([0-9a-z\-\_\.]+)\)\s+([a-f0-9]+)/im;
var branchlessTagRegEx =
/^\*\s*\(no branch\)\s+([a-z0-9]+)\s+(\[([0-9a-z\-\_\.\/]+)(\:[\sa-z0-9]+)*\])?.*$/mi;

var branchlessTag2RegEx =
/^\*\s*\([a-zA-Z0-9\_\-\.\/]+ detached at ([0-9a-z\-\_\.\/]+)\)\s+([a-z0-9]+).*$/mi;

var matchRefsRefEx = /^([a-f0-9]+)\s+refs\/(heads|tags)\/(.*)$/mi;

var makeCleanRepoDirs = function makeCleanRepoDirs (path, parentDir, cacheRepoPath) {
  var deferred = q.defer();

  rmdir(path, function(err) {
    if (err) {
      deferred.reject(err);
      return;
    }

    mkdirp(parentDir, function(err) {
      if (err) {
        deferred.reject(err);
        return;
      }

      mkdirp(cacheRepoPath, function(err) {
        if (err) {
          deferred.reject(err);
          return;
        }

        deferred.resolve();
      });
    });
  });

  return deferred.promise;
};


var Repo = function Repo(path, info, cacheDir) {
  this.path = path;
  this.cacheDir = cacheDir;

  info = info||{};
  this.detached = info.detached === true;
  if (info.url) this.url = info.url;
  if (info.branch) this.branch = info.branch;
  if (info.remote) this.remote = info.remote;
  if (info.commit) this.commit = info.commit;
};

Repo.prototype.valueOf = Repo.prototype.toString = function() {
  return this.url + '#' + this.location;
};

Object.defineProperty(Repo.prototype, 'location', {
  get: function() {
    if (this.detached === true) {
      return '(detached at ' + this.commit + ')';
    }
    else if (this.branch) {
      return this.branch;
    }
    else {
      return '(unknown)';
    }
  }
});

Repo.prototype.set = function(repoInfo) {
  for (var name in repoInfo) {
    if (repoInfo.hasOwnProperty(name)) {
      this[name] = repoInfo[name];
    }
  }

  return this;
};

Repo.prototype.getBranchInfo = function() {
  return Repo.getBranchInfo(this.path)
              .then(function(info) {
                this.set(info);
                return info;
              }.bind(this));
};


Repo.prototype.getRemoteUrl = function () {
  return Repo.getRemoteUrlFor(this.path)
              .then(function(url) {
                this.url = url;
                return this.url;
              }.bind(this));
};

// Update the repo
//
// we don't bother to update detached repos, we assume that they are
// exactly where they need to be. We also don't bother with repos
// without known remotes as we don't know where to pull from
//
Repo.prototype.update = function() {
  if (this.detached && !this.remote) {
    // @fixme This probably isn't the right way of doing this
    var deferred = q.defer();
    deferred.resolve();
    return deferred.promise;
  }

  if ( !(this.branch && this.remote) ) {
    return this.getBranchInfo()
              .then(function() {
                if (this.detached === false && this.remote) {
                  return Repo.update(this.path, this.remote, this.branch);
                }
              }.bind(this));
  }

  return Repo.update(this.path, this.remote, this.branch);
};

Repo.prototype.setup = function() {
  return Repo.setup(this.url, this.branch, this.path, this.cacheDir)
              .then(function(repo) {
                if (!this.url && repo.url) this.url = repo.url;
                if (!this.branch && repo.branch) this.branch = repo.branch;
              }.bind(this));
};

Repo.exists = function(repoPath) {
  return util.exists(repoPath + 'package.json');
};


Repo.getBranchInfo = function(path) {
  return util.executeCommand('git', ['branch', '-vv'], path)
              .then(function(data) {
                data = data.trim();
                var extractedInfo = detachedModeRegEx.exec(data),
                    detachedMode = extractedInfo && extractedInfo.length > 1,
                    checkout = {detached:false};

                if (!detachedMode) {
                  // newer syntax
                  extractedInfo = detachedMode2RegEx.exec(data),
                  detachedMode = extractedInfo && extractedInfo.length > 1;
                }

                // is it in detached mode?
                if (detachedMode) {

                  extractedInfo = branchlessTagRegEx.exec(data);

                  if (!extractedInfo || !extractedInfo.length) {
                    extractedInfo = branchlessTag2RegEx.exec(data);
                  }

                  if (extractedInfo && extractedInfo.length) {
                    checkout.detached = true;
                    if (extractedInfo[2]) checkout.commit = extractedInfo[2];

                    // @todo work out if it's a bare commit or a named tag
                    return Repo.getInfo(path).then(function(info) {
                      if (info.branches[extractedInfo[1]]) {
                        checkout.branch = extractedInfo[1];
                      } else if (info.tags[extractedInfo[1]]) {
                        checkout.tag = extractedInfo[1];
                      }

                      return checkout;
                    });
                  }
                }

                extractedInfo = branchRegEx.exec(data);

                if (!extractedInfo || !extractedInfo[1]) {
                  extractedInfo = branchlessTagRegEx.exec(data);
                }

                if (!extractedInfo || !extractedInfo[1]) {
                  throw new Error('Couldn\'t find Repo branch or tag info for ' + path.underline);
                }

                checkout.branch = extractedInfo[1];
                if (extractedInfo[2]) checkout.commit = extractedInfo[2];
                if (extractedInfo[4]) checkout.remote = extractedInfo[4].split('/')[0];

                return checkout;
              });
};

Repo.getInfo = function(path) {
  return Repo.getRefs(path)
              .then(function(refs) {
                var info = {
                  branches: {},
                  tags: {}
                };

                refs.forEach(function(ref) {
                  info[ ref.type === 'branch' ? 'branches' : 'tags' ][ref.name] = ref.commit;
                });

                return info;
              });
};

Repo.getRefs = function(path) {
  return util.executeCommand('git', ['ls-remote', '--tags', '--heads', '.'], path)
              .then(function(data) {
                var refs = [],
                    ref;

                data.trim()
                    .replace(/[\t ]+/g, ' ')
                    .split(/[\r\n]+/).forEach(function(line) {
                      ref = matchRefsRefEx.exec(line);

                      refs.push({
                        type: ref[2] === 'heads' ? 'branch' : 'tag',
                        commit: ref[1],
                        name: ref[3]
                      });
                    });

                return refs;
              });

};


Repo.getRemoteName = function(path) {
  return Repo.getBranchInfo(path)
              .then(function(info) {
                return info.remote;
              });
};

Repo.getRemoteUrlFor = function (path) {
  return util.executeCommand('git', ['config', '--get', 'remote.origin.url'], path)
                .then(function(url) {
                  return url.replace(/(?:\r\n|\r|\n)/g, '');
                });
};

// @todo deal with tags
Repo.update = function(path, remote, branch) {
  util.log('Checking ' + (remote + '/' + (branch || '')).bold +
                    ' for remote changes');

  return Repo.status(path, remote, branch)
              .then(function(status) {
                if (status == 'RemoteAhead') return;

                util.log('Pulling latest from ' + (remote + '/' + (branch || '')).bold);

                return util.executeCommand('git', ['merge', remote + '/' + branch], path);
              })
              .catch(function(error) {
                if (error.details.match(/error: Your local changes/)) {
                  console.warn(('Warning: ' + path + ' could not be updated, because of local changes:').yellow.bold);
                  console.warn(error.details.yellow.bold);
                } else {
                  throw error;
                }
              })
              .then(function() {
                return;
              });
};

// This needs a tidy up
Repo.status = function(path, remote, branch) {
  return util.executeCommand('git', ['fetch', remote], path)
              .then(function() {
                return q.allSettled([
                  util.executeCommand('git', ['rev-parse', '@'], path),
                  util.executeCommand('git', ['rev-parse', '@{u}'], path),
                  util.executeCommand('git', ['merge-base', '@', '@{u}'], path),
                ]);
              }).spread(function(local, remote, base) {
                if (local === remote) {
                  return 'UpToDate';
                }
                else if (local === base) {
                  return 'RemoteAhead';
                }
                else if (remote === base) {
                  return 'LocalAhead';
                }
                else {
                  return 'Diverged';
                }
              });
};


// @todo deal with tags
Repo.clone = function(name, url, branch, path) {
  var args = ['clone'];

  if (branch) args.push('-b' + branch);
  args.push('--progress');
  args.push('--depth', 1);
  args.push(url);
  args.push('./');

  util.log('Cloning ' + (name + '#' + branch).bold + ' into ' + path.underline);

  return util.executeCommand('git', args, path)
              .then(function() {
                return Repo.getBranchInfo(path);
              })
              .then(function(info) {
                info.branch = branch;
                info.url = url;
                return new Repo(path, info);
              });
};


Repo.setup = function(url, branch, path, cacheDir) {
  var parentDir = path.split('/'),
      name;

  if (parentDir[parentDir.length-1].length === 0) {
    parentDir.pop();
  }

  name  = parentDir.pop();
  parentDir = parentDir.join('/');

  return Repo.exists(path)
          .then(function(exists) {
            if (exists) {
              return Repo.getBranchInfo(path)
                          .then(function(info) {
                            // we don't bother to update detached repos, we assume
                            // that they are exactly where they need to be. We also
                            // don't bother with repos without known remotes as we
                            // don't know where to pull from
                            if (info.detached === true || !info.remote) {
                              return Repo.update(parentDir, info.remote, branch);
                            }
                          });
            }

            var cacheRepoPath = cacheDir + name + '/' + branch + '/';

            return makeCleanRepoDirs(path, parentDir, cacheRepoPath)
                    .then(function() {
                      return util.exists(cacheRepoPath + 'package.json');
                    })
                    .then(function(exists) {
                      if (exists) {
                        // This repo has already been checked out, just symlink it
                        // into place
                        return q.nfcall(fs.symlink, cacheRepoPath,
                                          path.substr(0, path.length-1), 'dir');
                      }

                      var repo;
                      return Repo.clone(name, url, branch, cacheRepoPath)
                                .then(function(_repo) {
                                  repo = _repo;
                                  return q.nfcall(fs.symlink, cacheRepoPath,
                                                path.substr(0, path.length-1), 'dir')
                                          .then(function() {
                                            return repo;
                                          });
                                });
                    });
          });
};


module.exports = Repo;
